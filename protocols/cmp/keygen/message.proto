syntax = "proto3";

package refresh;

option go_package = "github.com/taurusgroup/cmp-ecdsa/protocol/keygen";

option (gogoproto.stable_marshaler_all) = true;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

import "pkg/paillier/ciphertext.proto";
import "pkg/math/polynomial/exponent.proto";
import "pkg/zk/mod/mod.proto";
import "pkg/zk/prm/prm.proto";
import "pkg/pedersen/pedersen.proto";

message Keygen2 {
  option (gogoproto.goproto_getters) = false;
  // Commitment = Vᵢ = H(ρᵢ, Fᵢ(X), Aᵢ, Nᵢ, sᵢ, tᵢ, uᵢ)
  bytes Commitment = 1;
}

message Keygen3 {
  option (gogoproto.goproto_getters) = false;
  // HashEcho = H(V₁, …, Vₙ)
  // This is essentially an echo of all messages from Keygen2.
  // If one party received something different then everybody must abort.
  bytes HashEcho = 1;
}

message Keygen4 {
  option (gogoproto.goproto_getters) = false;
  // RID = RIDᵢ
  bytes RID = 1;
  // VSSPolynomial = Fᵢ(X) VSSPolynomial
  polynomial.Exponent VSSPolynomial = 2;
  // SchnorrCommitments = Aᵢ Schnorr commitment for the final confirmation
  bytes SchnorrCommitments = 3 [(gogoproto.customtype) = "github.com/taurusgroup/cmp-ecdsa/pkg/math/curve.Point"];
  // N Paillier and Pedersen
  pedersen.Parameters Pedersen = 4;
  // Decommitment = uᵢ decommitment bytes
  bytes Decommitment = 5;
}

message Keygen5 {
  option (gogoproto.goproto_getters) = false;
  zkmod.Proof Mod = 1;
  zkprm.Proof Prm = 2;
  // Share = Encᵢ(x) is the encryption of the receivers share
  paillier.Ciphertext Share = 3;
}

message KeygenOutput {
  option (gogoproto.goproto_getters) = false;
  // Proof is the Schnorr proof of knowledge of the new secret share
  bytes Proof = 1 [(gogoproto.customtype) = "github.com/taurusgroup/cmp-ecdsa/pkg/math/curve.Scalar"];
}