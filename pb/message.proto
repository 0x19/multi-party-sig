syntax = "proto3";

package pb;

//option go_package = "github.com/taurusgroup/cmp-ecdsa/pb";

option (gogoproto.stable_marshaler_all) = true;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

import "types.proto";
import "zk.proto";

enum MessageType {
  MessageTypeInvalid = 0;

  MessageTypeRefresh1 = 11;
  MessageTypeRefresh2 = 12;
  MessageTypeRefresh3 = 13;
  MessageTypeRefresh4 = 14;

  MessageTypeSign1 = 21;
  MessageTypeSign2 = 22;
  MessageTypeSign3 = 23;
  MessageTypeSign4 = 24;

  MessageTypeAbort1 = 31;
  MessageTypeAbort2 = 32;
}

enum Broadcast {
  None = 0;
  Basic = 1;
  Reliable = 2;
}

message Message {
  MessageType type = 1;
  string from = 2 [(gogoproto.customtype) = "github.com/taurusgroup/cmp-ecdsa/pkg/party.ID", (gogoproto.nullable) = false];
  string to = 3 [(gogoproto.customtype) = "github.com/taurusgroup/cmp-ecdsa/pkg/party.ID", (gogoproto.nullable) = false];
  Broadcast broadcast = 4;

  Refresh1 refresh1 = 11;
  Refresh2 refresh2 = 12;
  Refresh3 refresh3 = 13;
  Refresh4 refresh4 = 14;

  Sign1 sign1 = 21;
  Sign2 sign2 = 22;
  Sign3 sign3 = 23;
  Sign4 sign4 = 24;

  Abort1 abort1 = 31;
  Abort2 abort2 = 32;
}

message Refresh1 {
  // hash = V_i = H(rho_i, F_i(X), {A_i,l}, N_i, s_i, t_i, u_i)
  bytes hash = 1;
}

message Refresh2 {
  // hashOfHashes = H(V_1, ..., V_n)
  // This is essentially an echo of all messages from Refresh1.
  // If one party received something different then everybody must abort.
  bytes hashOfHashes = 1;
}

message Refresh3 {
  // rho = rho_i
  bytes rho = 1;
  // f = F_i(X) VSS polynomial
  PolynomialExponent f = 2;
  // A = {A_i,l}_l Schnorr commitments for the coefficients of F_i
  repeated Point A = 3;
  // N Paillier and Pedersen
  bytes N = 4 [(gogoproto.casttypewith) = "math/big.Int;IntCaster"];
  // S Pedersen
  bytes S = 5 [(gogoproto.casttypewith) = "math/big.Int;IntCaster"];
  // T Pedersen
  bytes T = 6 [(gogoproto.casttypewith) = "math/big.Int;IntCaster"];
  // U decommitment bytes
  bytes u = 7;
}

message Refresh4 {
  ZKMod mod = 1;
  ZKPrm prm = 2;
  // c = Enc_i(x) is the encryption of the receivers share
  bytes c = 3 [(gogoproto.casttypewith) = "github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster"];
  // schF are the Schnorr proofs of knowledge of the coefficients of the VSS polynomial
  repeated Scalar schF = 4;
}

message Sign1 {
  ZKEnc enc = 1;
  bytes K = 2 [(gogoproto.casttypewith) = "github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster"];
  bytes G = 3 [(gogoproto.casttypewith) = "github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster"];
}

message Sign2 {
  bytes hashKG = 1;
  Point Gamma = 2;
  bytes D = 3 [(gogoproto.casttypewith) = "github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster"];
  bytes F = 4 [(gogoproto.casttypewith) = "github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster"];
  bytes DHat = 5 [(gogoproto.casttypewith) = "github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster"];
  bytes FHat = 6 [(gogoproto.casttypewith) = "github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster"];
  ZKAffG ProofAffG = 7;
  ZKAffG ProofAffGHat = 8;
  ZKLogStar ProofLog = 9;
}

message Sign3 {
  Scalar Delta = 1;
  Point DeltaGroup = 2;
  ZKLogStar ProofLog = 3;
}

message Sign4 {
  Scalar Sigma = 1;
}

message Abort1 {
  map <string, ZKAffG> proofAffg = 1;
  ZKMul proofMul = 2;
  map <string, ZKDec> proofDec = 3;
}

message Abort2 {
  map <string, ZKAffG> proofAffg = 1;
  map <string, ZKMulStar> proofMul = 2;
  map <string, ZKDec> proofDec = 3;
}

message Frost1 {
  Point D = 1;
  Point E = 2;
}

message Frost2 {
  Scalar Z = 1;
}