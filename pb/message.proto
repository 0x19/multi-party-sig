syntax = "proto3";

package pb;

option go_package = "github.com/taurusgroup/cmp-ecdsa/pb";

import "types.proto";
import "zk.proto";

enum MessageType {
  TypeInvalid = 0;

  TypeRefresh1 = 11;
  TypeRefresh2 = 12;
  TypeRefresh3 = 13;
  TypeRefresh4 = 14;

  TypeSign1 = 21;
  TypeSign2 = 22;
  TypeSign3 = 23;
  TypeSign4 = 24;

  TypeAbort1 = 31;
  TypeAbort2 = 32;

  TypeKeygenOld1 = 111;
  TypeKeygenOld2 = 112;
  TypeKeygenOld3 = 113;

  TypeRefreshOld1 = 121;
  TypeRefreshOld2 = 122;
  TypeRefreshOld3 = 123;
}

enum Broadcast {
  None = 0;
  Basic = 1;
  Reliable = 2;
}

message Message {
  MessageType type = 1;
  string from = 2;
  string to = 3;
  Broadcast broadcast = 4;

  Refresh1 refresh1 = 11;
  Refresh2 refresh2 = 12;
  Refresh3 refresh3 = 13;
  Refresh4 refresh4 = 14;

  Sign1 sign1 = 21;
  Sign2 sign2 = 22;
  Sign3 sign3 = 23;
  Sign4 sign4 = 24;

  Abort1 abort1 = 31;
  Abort2 abort2 = 32;

  KeygenOld1 keygenOld1 = 111;
  KeygenOld2 keygenOld2 = 112;
  KeygenOld3 keygenOld3 = 113;

  RefreshOld1 refreshOld1 = 121;
  RefreshOld2 refreshOld2 = 122;
  RefreshOld3 refreshOld3 = 123;
}

message Refresh1 {
  // hash = V_i = H(rho_i, F_i(X), {A_i,l}, N_i, s_i, t_i, u_i)
  bytes hash = 1;
}

message Refresh2 {
  // hashOfHashes = H(V_1, ..., V_n)
  // This is essentially an echo of all messages from Refresh1.
  // If one party received something different then everybody must abort.
  bytes hashOfHashes = 1;
}

message Refresh3 {
  // rho = rho_i
  bytes rho = 1;
  // f = F_i(X) VSS polynomial
  PolynomialExponent f = 2;
  // A = {A_i,l}_l Schnorr commitments for the coefficients of F_i
  repeated Point A = 3;
  // N Paillier and Pedersen
  Int N = 4;
  // S Pedersen
  Int S = 5;
  // T Pedersen
  Int T = 6;
  // U decommitment bytes
  bytes u = 7;
}

message Refresh4 {
  ZKMod mod = 1;
  ZKPrm prm = 2;
  // c = Enc_i(x) is the encryption of the receivers share
  Ciphertext c = 3;
  // schF are the Schnorr proofs of knowledge of the coefficients of the VSS polynomial
  repeated Scalar schF = 4;
}

message Sign1 {
  ZKEnc enc = 1;
  Ciphertext K = 2;
  Ciphertext G = 3;
}

message Sign2 {
  bytes hashKG = 1;
  Point Gamma = 2;
  Ciphertext D = 3;
  Ciphertext F = 4;
  Ciphertext DHat = 5;
  Ciphertext FHat = 6;
  ZKAffG ProofAffG = 7;
  ZKAffG ProofAffGHat = 8;
  ZKLogStar ProofLog = 9;
}

message Sign3 {
  Scalar Delta = 1;
  Point DeltaGroup = 2;
  ZKLogStar ProofLog = 3;
}

message Sign4 {
  Scalar Sigma = 1;
}

message Abort1 {
  map <string, ZKAffG> proofAffg = 1;
  ZKMul proofMul = 2;
  map <string, ZKDec> proofDec = 3;
}

message Abort2 {
  map <string, ZKAffG> proofAffg = 1;
  map <string, ZKMulStar> proofMul = 2;
  map <string, ZKDec> proofDec = 3;
}

message KeygenOld1 {
  bytes hash = 1;
}

message KeygenOld2 {
  bytes rid = 1;
  Point X = 2;
  Point A = 3;
  bytes u = 4;

  bytes prevHash = 10;
}

message KeygenOld3 {
  Scalar schX = 1;
}

message RefreshOld1 {
  bytes hash = 1;
}

message RefreshOld2 {
  repeated Point X = 1;
  repeated Point A = 2;
  Point Y = 3;
  Point B = 4;
  Int N = 5;
  Int S = 6;
  Int T = 7;
  bytes rho = 8;
  bytes u = 9;
  bytes prevHash = 10;
}

message RefreshOld3 {
  ZKMod mod = 1;
  ZKPrm prm = 2;
  Ciphertext c = 3;
  repeated Scalar schX = 4;
  Scalar schY = 5;
}