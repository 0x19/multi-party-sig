// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: message.proto

package pb

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	github_com_taurusgroup_cmp_ecdsa_pkg_paillier "github.com/taurusgroup/cmp-ecdsa/pkg/paillier"
	github_com_taurusgroup_cmp_ecdsa_pkg_party "github.com/taurusgroup/cmp-ecdsa/pkg/party"
	io "io"
	math "math"
	math_big "math/big"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MessageType int32

const (
	MessageTypeInvalid  MessageType = 0
	MessageTypeRefresh1 MessageType = 11
	MessageTypeRefresh2 MessageType = 12
	MessageTypeRefresh3 MessageType = 13
	MessageTypeRefresh4 MessageType = 14
	MessageTypeSign1    MessageType = 21
	MessageTypeSign2    MessageType = 22
	MessageTypeSign3    MessageType = 23
	MessageTypeSign4    MessageType = 24
	MessageTypeAbort1   MessageType = 31
	MessageTypeAbort2   MessageType = 32
)

var MessageType_name = map[int32]string{
	0:  "MessageTypeInvalid",
	11: "MessageTypeRefresh1",
	12: "MessageTypeRefresh2",
	13: "MessageTypeRefresh3",
	14: "MessageTypeRefresh4",
	21: "MessageTypeSign1",
	22: "MessageTypeSign2",
	23: "MessageTypeSign3",
	24: "MessageTypeSign4",
	31: "MessageTypeAbort1",
	32: "MessageTypeAbort2",
}

var MessageType_value = map[string]int32{
	"MessageTypeInvalid":  0,
	"MessageTypeRefresh1": 11,
	"MessageTypeRefresh2": 12,
	"MessageTypeRefresh3": 13,
	"MessageTypeRefresh4": 14,
	"MessageTypeSign1":    21,
	"MessageTypeSign2":    22,
	"MessageTypeSign3":    23,
	"MessageTypeSign4":    24,
	"MessageTypeAbort1":   31,
	"MessageTypeAbort2":   32,
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{0}
}

type Broadcast int32

const (
	None     Broadcast = 0
	Basic    Broadcast = 1
	Reliable Broadcast = 2
)

var Broadcast_name = map[int32]string{
	0: "None",
	1: "Basic",
	2: "Reliable",
}

var Broadcast_value = map[string]int32{
	"None":     0,
	"Basic":    1,
	"Reliable": 2,
}

func (Broadcast) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{1}
}

type Message struct {
	Type      MessageType                                   `protobuf:"varint,1,opt,name=type,proto3,enum=pb.MessageType" json:"type,omitempty"`
	From      github_com_taurusgroup_cmp_ecdsa_pkg_party.ID `protobuf:"bytes,2,opt,name=from,proto3,customtype=github.com/taurusgroup/cmp-ecdsa/pkg/party.ID" json:"from"`
	To        github_com_taurusgroup_cmp_ecdsa_pkg_party.ID `protobuf:"bytes,3,opt,name=to,proto3,customtype=github.com/taurusgroup/cmp-ecdsa/pkg/party.ID" json:"to"`
	Broadcast Broadcast                                     `protobuf:"varint,4,opt,name=broadcast,proto3,enum=pb.Broadcast" json:"broadcast,omitempty"`
	Refresh1  *Refresh1                                     `protobuf:"bytes,11,opt,name=refresh1,proto3" json:"refresh1,omitempty"`
	Refresh2  *Refresh2                                     `protobuf:"bytes,12,opt,name=refresh2,proto3" json:"refresh2,omitempty"`
	Refresh3  *Refresh3                                     `protobuf:"bytes,13,opt,name=refresh3,proto3" json:"refresh3,omitempty"`
	Refresh4  *Refresh4                                     `protobuf:"bytes,14,opt,name=refresh4,proto3" json:"refresh4,omitempty"`
	Sign1     *Sign1                                        `protobuf:"bytes,21,opt,name=sign1,proto3" json:"sign1,omitempty"`
	Sign2     *Sign2                                        `protobuf:"bytes,22,opt,name=sign2,proto3" json:"sign2,omitempty"`
	Sign3     *Sign3                                        `protobuf:"bytes,23,opt,name=sign3,proto3" json:"sign3,omitempty"`
	Sign4     *Sign4                                        `protobuf:"bytes,24,opt,name=sign4,proto3" json:"sign4,omitempty"`
	Abort1    *Abort1                                       `protobuf:"bytes,31,opt,name=abort1,proto3" json:"abort1,omitempty"`
	Abort2    *Abort2                                       `protobuf:"bytes,32,opt,name=abort2,proto3" json:"abort2,omitempty"`
}

func (m *Message) Reset()      { *m = Message{} }
func (*Message) ProtoMessage() {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{0}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetType() MessageType {
	if m != nil {
		return m.Type
	}
	return MessageTypeInvalid
}

func (m *Message) GetBroadcast() Broadcast {
	if m != nil {
		return m.Broadcast
	}
	return None
}

func (m *Message) GetRefresh1() *Refresh1 {
	if m != nil {
		return m.Refresh1
	}
	return nil
}

func (m *Message) GetRefresh2() *Refresh2 {
	if m != nil {
		return m.Refresh2
	}
	return nil
}

func (m *Message) GetRefresh3() *Refresh3 {
	if m != nil {
		return m.Refresh3
	}
	return nil
}

func (m *Message) GetRefresh4() *Refresh4 {
	if m != nil {
		return m.Refresh4
	}
	return nil
}

func (m *Message) GetSign1() *Sign1 {
	if m != nil {
		return m.Sign1
	}
	return nil
}

func (m *Message) GetSign2() *Sign2 {
	if m != nil {
		return m.Sign2
	}
	return nil
}

func (m *Message) GetSign3() *Sign3 {
	if m != nil {
		return m.Sign3
	}
	return nil
}

func (m *Message) GetSign4() *Sign4 {
	if m != nil {
		return m.Sign4
	}
	return nil
}

func (m *Message) GetAbort1() *Abort1 {
	if m != nil {
		return m.Abort1
	}
	return nil
}

func (m *Message) GetAbort2() *Abort2 {
	if m != nil {
		return m.Abort2
	}
	return nil
}

type Refresh1 struct {
	// hash = V_i = H(rho_i, F_i(X), {A_i,l}, N_i, s_i, t_i, u_i)
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Refresh1) Reset()      { *m = Refresh1{} }
func (*Refresh1) ProtoMessage() {}
func (*Refresh1) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{1}
}
func (m *Refresh1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Refresh1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Refresh1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Refresh1.Merge(m, src)
}
func (m *Refresh1) XXX_Size() int {
	return m.Size()
}
func (m *Refresh1) XXX_DiscardUnknown() {
	xxx_messageInfo_Refresh1.DiscardUnknown(m)
}

var xxx_messageInfo_Refresh1 proto.InternalMessageInfo

func (m *Refresh1) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type Refresh2 struct {
	// hashOfHashes = H(V_1, ..., V_n)
	// This is essentially an echo of all messages from Refresh1.
	// If one party received something different then everybody must abort.
	HashOfHashes []byte `protobuf:"bytes,1,opt,name=hashOfHashes,proto3" json:"hashOfHashes,omitempty"`
}

func (m *Refresh2) Reset()      { *m = Refresh2{} }
func (*Refresh2) ProtoMessage() {}
func (*Refresh2) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{2}
}
func (m *Refresh2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Refresh2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Refresh2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Refresh2.Merge(m, src)
}
func (m *Refresh2) XXX_Size() int {
	return m.Size()
}
func (m *Refresh2) XXX_DiscardUnknown() {
	xxx_messageInfo_Refresh2.DiscardUnknown(m)
}

var xxx_messageInfo_Refresh2 proto.InternalMessageInfo

func (m *Refresh2) GetHashOfHashes() []byte {
	if m != nil {
		return m.HashOfHashes
	}
	return nil
}

type Refresh3 struct {
	// rho = rho_i
	Rho []byte `protobuf:"bytes,1,opt,name=rho,proto3" json:"rho,omitempty"`
	// f = F_i(X) VSS polynomial
	F *PolynomialExponent `protobuf:"bytes,2,opt,name=f,proto3" json:"f,omitempty"`
	// A = {A_i,l}_l Schnorr commitments for the coefficients of F_i
	A []*Point `protobuf:"bytes,3,rep,name=A,proto3" json:"A,omitempty"`
	// N Paillier and Pedersen
	N *math_big.Int `protobuf:"bytes,4,opt,name=N,proto3,casttypewith=math/big.Int;IntCaster" json:"N,omitempty"`
	// S Pedersen
	S *math_big.Int `protobuf:"bytes,5,opt,name=S,proto3,casttypewith=math/big.Int;IntCaster" json:"S,omitempty"`
	// T Pedersen
	T *math_big.Int `protobuf:"bytes,6,opt,name=T,proto3,casttypewith=math/big.Int;IntCaster" json:"T,omitempty"`
	// U decommitment bytes
	U []byte `protobuf:"bytes,7,opt,name=u,proto3" json:"u,omitempty"`
}

func (m *Refresh3) Reset()      { *m = Refresh3{} }
func (*Refresh3) ProtoMessage() {}
func (*Refresh3) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{3}
}
func (m *Refresh3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Refresh3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Refresh3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Refresh3.Merge(m, src)
}
func (m *Refresh3) XXX_Size() int {
	return m.Size()
}
func (m *Refresh3) XXX_DiscardUnknown() {
	xxx_messageInfo_Refresh3.DiscardUnknown(m)
}

var xxx_messageInfo_Refresh3 proto.InternalMessageInfo

func (m *Refresh3) GetRho() []byte {
	if m != nil {
		return m.Rho
	}
	return nil
}

func (m *Refresh3) GetF() *PolynomialExponent {
	if m != nil {
		return m.F
	}
	return nil
}

func (m *Refresh3) GetA() []*Point {
	if m != nil {
		return m.A
	}
	return nil
}

func (m *Refresh3) GetN() *math_big.Int {
	if m != nil {
		return m.N
	}
	return nil
}

func (m *Refresh3) GetS() *math_big.Int {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *Refresh3) GetT() *math_big.Int {
	if m != nil {
		return m.T
	}
	return nil
}

func (m *Refresh3) GetU() []byte {
	if m != nil {
		return m.U
	}
	return nil
}

type Refresh4 struct {
	Mod *ZKMod `protobuf:"bytes,1,opt,name=mod,proto3" json:"mod,omitempty"`
	Prm *ZKPrm `protobuf:"bytes,2,opt,name=prm,proto3" json:"prm,omitempty"`
	// c = Enc_i(x) is the encryption of the receivers share
	C *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext `protobuf:"bytes,3,opt,name=c,proto3,casttypewith=github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster" json:"c,omitempty"`
	// schF are the Schnorr proofs of knowledge of the coefficients of the VSS polynomial
	SchF []*Scalar `protobuf:"bytes,4,rep,name=schF,proto3" json:"schF,omitempty"`
}

func (m *Refresh4) Reset()      { *m = Refresh4{} }
func (*Refresh4) ProtoMessage() {}
func (*Refresh4) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{4}
}
func (m *Refresh4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Refresh4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Refresh4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Refresh4.Merge(m, src)
}
func (m *Refresh4) XXX_Size() int {
	return m.Size()
}
func (m *Refresh4) XXX_DiscardUnknown() {
	xxx_messageInfo_Refresh4.DiscardUnknown(m)
}

var xxx_messageInfo_Refresh4 proto.InternalMessageInfo

func (m *Refresh4) GetMod() *ZKMod {
	if m != nil {
		return m.Mod
	}
	return nil
}

func (m *Refresh4) GetPrm() *ZKPrm {
	if m != nil {
		return m.Prm
	}
	return nil
}

func (m *Refresh4) GetC() *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext {
	if m != nil {
		return m.C
	}
	return nil
}

func (m *Refresh4) GetSchF() []*Scalar {
	if m != nil {
		return m.SchF
	}
	return nil
}

type Sign1 struct {
	Enc *ZKEnc                                                    `protobuf:"bytes,1,opt,name=enc,proto3" json:"enc,omitempty"`
	K   *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext `protobuf:"bytes,2,opt,name=K,proto3,casttypewith=github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster" json:"K,omitempty"`
	G   *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext `protobuf:"bytes,3,opt,name=G,proto3,casttypewith=github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster" json:"G,omitempty"`
}

func (m *Sign1) Reset()      { *m = Sign1{} }
func (*Sign1) ProtoMessage() {}
func (*Sign1) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{5}
}
func (m *Sign1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sign1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Sign1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sign1.Merge(m, src)
}
func (m *Sign1) XXX_Size() int {
	return m.Size()
}
func (m *Sign1) XXX_DiscardUnknown() {
	xxx_messageInfo_Sign1.DiscardUnknown(m)
}

var xxx_messageInfo_Sign1 proto.InternalMessageInfo

func (m *Sign1) GetEnc() *ZKEnc {
	if m != nil {
		return m.Enc
	}
	return nil
}

func (m *Sign1) GetK() *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext {
	if m != nil {
		return m.K
	}
	return nil
}

func (m *Sign1) GetG() *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext {
	if m != nil {
		return m.G
	}
	return nil
}

type Sign2 struct {
	HashKG       []byte                                                    `protobuf:"bytes,1,opt,name=hashKG,proto3" json:"hashKG,omitempty"`
	Gamma        *Point                                                    `protobuf:"bytes,2,opt,name=Gamma,proto3" json:"Gamma,omitempty"`
	D            *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext `protobuf:"bytes,3,opt,name=D,proto3,casttypewith=github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster" json:"D,omitempty"`
	F            *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext `protobuf:"bytes,4,opt,name=F,proto3,casttypewith=github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster" json:"F,omitempty"`
	DHat         *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext `protobuf:"bytes,5,opt,name=DHat,proto3,casttypewith=github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster" json:"DHat,omitempty"`
	FHat         *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext `protobuf:"bytes,6,opt,name=FHat,proto3,casttypewith=github.com/taurusgroup/cmp-ecdsa/pkg/paillier.Ciphertext;CiphertextCaster" json:"FHat,omitempty"`
	ProofAffG    *ZKAffG                                                   `protobuf:"bytes,7,opt,name=ProofAffG,proto3" json:"ProofAffG,omitempty"`
	ProofAffGHat *ZKAffG                                                   `protobuf:"bytes,8,opt,name=ProofAffGHat,proto3" json:"ProofAffGHat,omitempty"`
	ProofLog     *ZKLogStar                                                `protobuf:"bytes,9,opt,name=ProofLog,proto3" json:"ProofLog,omitempty"`
}

func (m *Sign2) Reset()      { *m = Sign2{} }
func (*Sign2) ProtoMessage() {}
func (*Sign2) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{6}
}
func (m *Sign2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sign2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Sign2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sign2.Merge(m, src)
}
func (m *Sign2) XXX_Size() int {
	return m.Size()
}
func (m *Sign2) XXX_DiscardUnknown() {
	xxx_messageInfo_Sign2.DiscardUnknown(m)
}

var xxx_messageInfo_Sign2 proto.InternalMessageInfo

func (m *Sign2) GetHashKG() []byte {
	if m != nil {
		return m.HashKG
	}
	return nil
}

func (m *Sign2) GetGamma() *Point {
	if m != nil {
		return m.Gamma
	}
	return nil
}

func (m *Sign2) GetD() *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext {
	if m != nil {
		return m.D
	}
	return nil
}

func (m *Sign2) GetF() *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext {
	if m != nil {
		return m.F
	}
	return nil
}

func (m *Sign2) GetDHat() *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext {
	if m != nil {
		return m.DHat
	}
	return nil
}

func (m *Sign2) GetFHat() *github_com_taurusgroup_cmp_ecdsa_pkg_paillier.Ciphertext {
	if m != nil {
		return m.FHat
	}
	return nil
}

func (m *Sign2) GetProofAffG() *ZKAffG {
	if m != nil {
		return m.ProofAffG
	}
	return nil
}

func (m *Sign2) GetProofAffGHat() *ZKAffG {
	if m != nil {
		return m.ProofAffGHat
	}
	return nil
}

func (m *Sign2) GetProofLog() *ZKLogStar {
	if m != nil {
		return m.ProofLog
	}
	return nil
}

type Sign3 struct {
	Delta      *Scalar    `protobuf:"bytes,1,opt,name=Delta,proto3" json:"Delta,omitempty"`
	DeltaGroup *Point     `protobuf:"bytes,2,opt,name=DeltaGroup,proto3" json:"DeltaGroup,omitempty"`
	ProofLog   *ZKLogStar `protobuf:"bytes,3,opt,name=ProofLog,proto3" json:"ProofLog,omitempty"`
}

func (m *Sign3) Reset()      { *m = Sign3{} }
func (*Sign3) ProtoMessage() {}
func (*Sign3) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{7}
}
func (m *Sign3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sign3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Sign3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sign3.Merge(m, src)
}
func (m *Sign3) XXX_Size() int {
	return m.Size()
}
func (m *Sign3) XXX_DiscardUnknown() {
	xxx_messageInfo_Sign3.DiscardUnknown(m)
}

var xxx_messageInfo_Sign3 proto.InternalMessageInfo

func (m *Sign3) GetDelta() *Scalar {
	if m != nil {
		return m.Delta
	}
	return nil
}

func (m *Sign3) GetDeltaGroup() *Point {
	if m != nil {
		return m.DeltaGroup
	}
	return nil
}

func (m *Sign3) GetProofLog() *ZKLogStar {
	if m != nil {
		return m.ProofLog
	}
	return nil
}

type Sign4 struct {
	Sigma *Scalar `protobuf:"bytes,1,opt,name=Sigma,proto3" json:"Sigma,omitempty"`
}

func (m *Sign4) Reset()      { *m = Sign4{} }
func (*Sign4) ProtoMessage() {}
func (*Sign4) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{8}
}
func (m *Sign4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sign4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Sign4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sign4.Merge(m, src)
}
func (m *Sign4) XXX_Size() int {
	return m.Size()
}
func (m *Sign4) XXX_DiscardUnknown() {
	xxx_messageInfo_Sign4.DiscardUnknown(m)
}

var xxx_messageInfo_Sign4 proto.InternalMessageInfo

func (m *Sign4) GetSigma() *Scalar {
	if m != nil {
		return m.Sigma
	}
	return nil
}

type Abort1 struct {
	ProofAffg map[string]*ZKAffG `protobuf:"bytes,1,rep,name=proofAffg,proto3" json:"proofAffg,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ProofMul  *ZKMul             `protobuf:"bytes,2,opt,name=proofMul,proto3" json:"proofMul,omitempty"`
	ProofDec  map[string]*ZKDec  `protobuf:"bytes,3,rep,name=proofDec,proto3" json:"proofDec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Abort1) Reset()      { *m = Abort1{} }
func (*Abort1) ProtoMessage() {}
func (*Abort1) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{9}
}
func (m *Abort1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Abort1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Abort1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Abort1.Merge(m, src)
}
func (m *Abort1) XXX_Size() int {
	return m.Size()
}
func (m *Abort1) XXX_DiscardUnknown() {
	xxx_messageInfo_Abort1.DiscardUnknown(m)
}

var xxx_messageInfo_Abort1 proto.InternalMessageInfo

func (m *Abort1) GetProofAffg() map[string]*ZKAffG {
	if m != nil {
		return m.ProofAffg
	}
	return nil
}

func (m *Abort1) GetProofMul() *ZKMul {
	if m != nil {
		return m.ProofMul
	}
	return nil
}

func (m *Abort1) GetProofDec() map[string]*ZKDec {
	if m != nil {
		return m.ProofDec
	}
	return nil
}

type Abort2 struct {
	ProofAffg map[string]*ZKAffG    `protobuf:"bytes,1,rep,name=proofAffg,proto3" json:"proofAffg,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ProofMul  map[string]*ZKMulStar `protobuf:"bytes,2,rep,name=proofMul,proto3" json:"proofMul,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ProofDec  map[string]*ZKDec     `protobuf:"bytes,3,rep,name=proofDec,proto3" json:"proofDec,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Abort2) Reset()      { *m = Abort2{} }
func (*Abort2) ProtoMessage() {}
func (*Abort2) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{10}
}
func (m *Abort2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Abort2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Abort2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Abort2.Merge(m, src)
}
func (m *Abort2) XXX_Size() int {
	return m.Size()
}
func (m *Abort2) XXX_DiscardUnknown() {
	xxx_messageInfo_Abort2.DiscardUnknown(m)
}

var xxx_messageInfo_Abort2 proto.InternalMessageInfo

func (m *Abort2) GetProofAffg() map[string]*ZKAffG {
	if m != nil {
		return m.ProofAffg
	}
	return nil
}

func (m *Abort2) GetProofMul() map[string]*ZKMulStar {
	if m != nil {
		return m.ProofMul
	}
	return nil
}

func (m *Abort2) GetProofDec() map[string]*ZKDec {
	if m != nil {
		return m.ProofDec
	}
	return nil
}

type Frost1 struct {
	D *Point `protobuf:"bytes,1,opt,name=D,proto3" json:"D,omitempty"`
	E *Point `protobuf:"bytes,2,opt,name=E,proto3" json:"E,omitempty"`
}

func (m *Frost1) Reset()      { *m = Frost1{} }
func (*Frost1) ProtoMessage() {}
func (*Frost1) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{11}
}
func (m *Frost1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Frost1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Frost1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Frost1.Merge(m, src)
}
func (m *Frost1) XXX_Size() int {
	return m.Size()
}
func (m *Frost1) XXX_DiscardUnknown() {
	xxx_messageInfo_Frost1.DiscardUnknown(m)
}

var xxx_messageInfo_Frost1 proto.InternalMessageInfo

func (m *Frost1) GetD() *Point {
	if m != nil {
		return m.D
	}
	return nil
}

func (m *Frost1) GetE() *Point {
	if m != nil {
		return m.E
	}
	return nil
}

type Frost2 struct {
	Z *Scalar `protobuf:"bytes,1,opt,name=Z,proto3" json:"Z,omitempty"`
}

func (m *Frost2) Reset()      { *m = Frost2{} }
func (*Frost2) ProtoMessage() {}
func (*Frost2) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{12}
}
func (m *Frost2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Frost2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Frost2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Frost2.Merge(m, src)
}
func (m *Frost2) XXX_Size() int {
	return m.Size()
}
func (m *Frost2) XXX_DiscardUnknown() {
	xxx_messageInfo_Frost2.DiscardUnknown(m)
}

var xxx_messageInfo_Frost2 proto.InternalMessageInfo

func (m *Frost2) GetZ() *Scalar {
	if m != nil {
		return m.Z
	}
	return nil
}

func init() {
	proto.RegisterEnum("pb.MessageType", MessageType_name, MessageType_value)
	proto.RegisterEnum("pb.Broadcast", Broadcast_name, Broadcast_value)
	proto.RegisterType((*Message)(nil), "pb.Message")
	proto.RegisterType((*Refresh1)(nil), "pb.Refresh1")
	proto.RegisterType((*Refresh2)(nil), "pb.Refresh2")
	proto.RegisterType((*Refresh3)(nil), "pb.Refresh3")
	proto.RegisterType((*Refresh4)(nil), "pb.Refresh4")
	proto.RegisterType((*Sign1)(nil), "pb.Sign1")
	proto.RegisterType((*Sign2)(nil), "pb.Sign2")
	proto.RegisterType((*Sign3)(nil), "pb.Sign3")
	proto.RegisterType((*Sign4)(nil), "pb.Sign4")
	proto.RegisterType((*Abort1)(nil), "pb.Abort1")
	proto.RegisterMapType((map[string]*ZKAffG)(nil), "pb.Abort1.ProofAffgEntry")
	proto.RegisterMapType((map[string]*ZKDec)(nil), "pb.Abort1.ProofDecEntry")
	proto.RegisterType((*Abort2)(nil), "pb.Abort2")
	proto.RegisterMapType((map[string]*ZKAffG)(nil), "pb.Abort2.ProofAffgEntry")
	proto.RegisterMapType((map[string]*ZKDec)(nil), "pb.Abort2.ProofDecEntry")
	proto.RegisterMapType((map[string]*ZKMulStar)(nil), "pb.Abort2.ProofMulEntry")
	proto.RegisterType((*Frost1)(nil), "pb.Frost1")
	proto.RegisterType((*Frost2)(nil), "pb.Frost2")
}

func init() { proto.RegisterFile("message.proto", fileDescriptor_33c57e4bae7b9afd) }

var fileDescriptor_33c57e4bae7b9afd = []byte{
	// 1197 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x97, 0xcf, 0x8f, 0xdb, 0x44,
	0x14, 0xc7, 0x33, 0x49, 0x36, 0x4d, 0x66, 0x93, 0xc5, 0x0c, 0x74, 0x77, 0x58, 0x24, 0x27, 0x72,
	0x41, 0xda, 0x16, 0x35, 0xd1, 0x3a, 0x46, 0x54, 0xed, 0x69, 0xd3, 0xfc, 0x68, 0xd8, 0xa6, 0xac,
	0x9c, 0x9e, 0x96, 0xd3, 0xc4, 0xeb, 0x38, 0x56, 0xed, 0x8c, 0x65, 0x3b, 0x55, 0xc3, 0x05, 0xee,
	0x1c, 0xe0, 0xcf, 0x40, 0x3d, 0xf1, 0x2f, 0x70, 0x40, 0xea, 0xb1, 0xc7, 0x8a, 0x43, 0xcb, 0xa6,
	0x07, 0x38, 0xf6, 0x4f, 0x40, 0x33, 0x9e, 0x38, 0x76, 0x13, 0xb5, 0x48, 0xec, 0x72, 0x9b, 0x79,
	0xdf, 0x8f, 0xdf, 0xbc, 0xf7, 0xfc, 0x5e, 0x3c, 0x81, 0x15, 0xd7, 0x0c, 0x02, 0x62, 0x99, 0x75,
	0xcf, 0xa7, 0x21, 0x45, 0x59, 0x6f, 0xb4, 0x7f, 0xd3, 0xb2, 0xc3, 0xc9, 0x6c, 0x54, 0x37, 0xa8,
	0xdb, 0xb0, 0xa8, 0x45, 0x1b, 0x5c, 0x1a, 0xcd, 0xc6, 0x7c, 0xc7, 0x37, 0x7c, 0x15, 0x3d, 0xb2,
	0xbf, 0x1d, 0xce, 0x3d, 0x33, 0x10, 0x9b, 0xe2, 0x77, 0x8f, 0xa2, 0x95, 0x72, 0x9e, 0x87, 0x57,
	0x06, 0x91, 0x6f, 0x74, 0x0d, 0xe6, 0x19, 0x84, 0x41, 0x0d, 0x1c, 0xec, 0xa8, 0x1f, 0xd4, 0xbd,
	0x51, 0x5d, 0x48, 0x0f, 0xe7, 0x9e, 0xa9, 0x73, 0x11, 0xf5, 0x61, 0x7e, 0xec, 0x53, 0x17, 0x67,
	0x6b, 0xe0, 0xa0, 0xd4, 0xfa, 0xf2, 0xd9, 0xcb, 0x6a, 0xe6, 0x8f, 0x97, 0xd5, 0x64, 0x30, 0x21,
	0x99, 0xf9, 0xb3, 0xc0, 0xf2, 0xe9, 0xcc, 0x6b, 0x18, 0xae, 0x77, 0xd3, 0x34, 0xce, 0x02, 0xd2,
	0xf0, 0x1e, 0x59, 0x0d, 0x8f, 0xf8, 0xe1, 0xbc, 0xde, 0x6f, 0xeb, 0xdc, 0x05, 0xea, 0xc0, 0x6c,
	0x48, 0x71, 0xee, 0xbf, 0x38, 0xca, 0x86, 0x14, 0x7d, 0x01, 0x4b, 0x23, 0x9f, 0x92, 0x33, 0x83,
	0x04, 0x21, 0xce, 0xf3, 0xd8, 0x2b, 0x2c, 0xf6, 0xd6, 0xd2, 0xa8, 0xaf, 0x74, 0x74, 0x00, 0x8b,
	0xbe, 0x39, 0xf6, 0xcd, 0x60, 0x72, 0x88, 0xb7, 0x6b, 0xe0, 0x60, 0x5b, 0x2d, 0x33, 0x56, 0x17,
	0x36, 0x3d, 0x56, 0x13, 0xa4, 0x8a, 0xcb, 0x6b, 0xa4, 0x1a, 0x93, 0x6a, 0x82, 0x6c, 0xe2, 0xca,
	0x1a, 0xd9, 0x8c, 0xc9, 0x66, 0x82, 0xd4, 0xf0, 0xce, 0x1a, 0xa9, 0xc5, 0xa4, 0x86, 0xaa, 0x70,
	0x2b, 0xb0, 0xad, 0xe9, 0x21, 0xbe, 0xca, 0xb1, 0x12, 0xc3, 0x86, 0xcc, 0xa0, 0x47, 0xf6, 0x25,
	0xa0, 0xe2, 0xdd, 0x34, 0xa0, 0x46, 0x80, 0xba, 0x04, 0x9a, 0x78, 0x2f, 0x0d, 0x34, 0x23, 0xa0,
	0xb9, 0x04, 0x34, 0x8c, 0xd3, 0x80, 0x16, 0x01, 0x1a, 0x52, 0x60, 0x81, 0x8c, 0xa8, 0x1f, 0x1e,
	0xe2, 0x2a, 0x27, 0x20, 0x23, 0x8e, 0xb8, 0x45, 0x17, 0x4a, 0xcc, 0xa8, 0xb8, 0xf6, 0x16, 0xa3,
	0x0a, 0x46, 0x55, 0x64, 0x58, 0x5c, 0xd6, 0x17, 0x21, 0x98, 0x9f, 0x90, 0x60, 0xc2, 0x7b, 0xac,
	0xac, 0xf3, 0xb5, 0x52, 0x8f, 0x75, 0x15, 0x29, 0xb0, 0xcc, 0x6c, 0xdf, 0x8c, 0xef, 0x91, 0x60,
	0x62, 0x06, 0x82, 0x4b, 0xd9, 0x94, 0xbf, 0x40, 0xfc, 0x40, 0x13, 0x49, 0x30, 0xe7, 0x4f, 0xa8,
	0xe0, 0xd8, 0x12, 0x7d, 0x06, 0xc1, 0x98, 0xb7, 0xe7, 0xb6, 0xba, 0xcb, 0xa2, 0x39, 0xa1, 0xce,
	0x7c, 0x4a, 0x5d, 0x9b, 0x38, 0x9d, 0x27, 0x1e, 0x9d, 0x9a, 0xd3, 0x50, 0x07, 0x63, 0xb4, 0x07,
	0xc1, 0x11, 0xce, 0xd5, 0x72, 0xcb, 0xcc, 0x4f, 0xa8, 0xcd, 0x84, 0x23, 0x74, 0x00, 0xc1, 0x03,
	0xde, 0x46, 0xe5, 0xd6, 0xfe, 0xd3, 0x57, 0xd5, 0x5d, 0x97, 0x84, 0x93, 0xc6, 0xc8, 0xb6, 0xea,
	0xfd, 0x69, 0x78, 0xa7, 0x3f, 0x0d, 0xef, 0x92, 0x20, 0x34, 0x7d, 0x1d, 0x3c, 0x60, 0xe4, 0x10,
	0x6f, 0xbd, 0x9f, 0x1c, 0x32, 0xf2, 0x21, 0x2e, 0xbc, 0x9f, 0x7c, 0x88, 0xca, 0x10, 0xcc, 0xf0,
	0x15, 0x9e, 0x0c, 0x98, 0x29, 0xbf, 0xad, 0x32, 0xd5, 0xd0, 0xa7, 0x30, 0xe7, 0xd2, 0x33, 0x9e,
	0xa9, 0x88, 0xf9, 0xf4, 0x78, 0x40, 0xcf, 0x74, 0x66, 0x65, 0xa2, 0xe7, 0xbb, 0x22, 0x6d, 0x21,
	0x9e, 0xf8, 0xae, 0xce, 0xac, 0xe8, 0x5b, 0x08, 0x0c, 0x3e, 0x67, 0xe5, 0xd6, 0xe0, 0xe9, 0xab,
	0x6a, 0xff, 0x5f, 0xce, 0x98, 0xed, 0x38, 0xb6, 0xe9, 0xd7, 0xef, 0xda, 0xde, 0xc4, 0xf4, 0x43,
	0xf3, 0x49, 0x78, 0x67, 0xb5, 0x5c, 0x46, 0x6c, 0x20, 0x19, 0xe6, 0x03, 0x63, 0xd2, 0xc5, 0x79,
	0x5e, 0x4b, 0xfe, 0xfe, 0x87, 0x06, 0x71, 0x88, 0xaf, 0x73, 0xbb, 0xf2, 0x12, 0xc0, 0x2d, 0xde,
	0xb9, 0x2c, 0x46, 0x73, 0x6a, 0xa4, 0x13, 0xe8, 0x4c, 0x0d, 0x9d, 0x59, 0x59, 0x8c, 0xc7, 0x3c,
	0xfc, 0x8b, 0x8f, 0xf1, 0x98, 0x39, 0xef, 0x5d, 0x52, 0x01, 0x7a, 0xca, 0xef, 0xf9, 0x28, 0x41,
	0x15, 0xed, 0xc2, 0x02, 0x6b, 0xd4, 0xe3, 0x9e, 0x68, 0x47, 0xb1, 0x63, 0x93, 0xd6, 0x23, 0xae,
	0x4b, 0x92, 0xaf, 0x27, 0xea, 0xb7, 0xc8, 0xce, 0xe2, 0x6b, 0x5f, 0x52, 0x7c, 0x6d, 0xe6, 0xbc,
	0x2b, 0x1a, 0xfa, 0xa2, 0x9d, 0x77, 0x11, 0x81, 0xf9, 0xf6, 0x3d, 0x12, 0x8a, 0x31, 0xb8, 0x60,
	0xff, 0xdc, 0x35, 0x3b, 0xa2, 0xcb, 0x8e, 0x28, 0x5c, 0xca, 0x11, 0xcc, 0x35, 0x3a, 0x80, 0xa5,
	0x13, 0x9f, 0xd2, 0xf1, 0xd1, 0x78, 0xdc, 0xe3, 0xd3, 0x27, 0x1a, 0xf9, 0xf4, 0x98, 0x59, 0xf4,
	0x95, 0x88, 0xea, 0xb0, 0x1c, 0x6f, 0x58, 0x50, 0xc5, 0x35, 0x38, 0xa5, 0xa3, 0xeb, 0xb0, 0xc8,
	0xf7, 0xf7, 0xa9, 0x85, 0x4b, 0x9c, 0xad, 0x44, 0xec, 0x7d, 0x6a, 0x0d, 0x43, 0xe2, 0xeb, 0xb1,
	0xac, 0x7c, 0x1f, 0xb5, 0x51, 0x13, 0xd5, 0xe0, 0x56, 0xdb, 0x74, 0x42, 0x22, 0x26, 0x25, 0x39,
	0x52, 0x91, 0x80, 0xae, 0x43, 0xc8, 0x17, 0x3d, 0x96, 0xf6, 0x7a, 0x57, 0x25, 0xc4, 0x54, 0x00,
	0xb9, 0x77, 0x07, 0x70, 0x3d, 0x0a, 0x40, 0x63, 0x01, 0x0c, 0x6d, 0xcb, 0xdd, 0x18, 0x00, 0x17,
	0x94, 0x5f, 0xb3, 0xb0, 0x10, 0x7d, 0x09, 0xd0, 0x57, 0xb0, 0xe4, 0x89, 0x8c, 0x2d, 0x0c, 0xf8,
	0x8f, 0xc0, 0x27, 0xab, 0x0f, 0x45, 0x7d, 0x59, 0x0d, 0xab, 0x33, 0x0d, 0xfd, 0xb9, 0xbe, 0x62,
	0xd1, 0xe7, 0xb0, 0xc8, 0x37, 0x83, 0x99, 0x93, 0xfe, 0xdd, 0x1a, 0xcc, 0x1c, 0x3d, 0x96, 0x90,
	0x26, 0xb0, 0xb6, 0x69, 0x88, 0xdf, 0x6b, 0xfc, 0xb6, 0xfb, 0xb6, 0x69, 0x44, 0xde, 0x63, 0x72,
	0xff, 0x1e, 0xdc, 0x49, 0x9f, 0xcc, 0x3e, 0x14, 0x8f, 0xcc, 0x39, 0x4f, 0xa9, 0xa4, 0xb3, 0x25,
	0x4b, 0xf3, 0x31, 0x71, 0x66, 0xa6, 0x38, 0x3d, 0xf9, 0x12, 0x23, 0xe1, 0x76, 0xf6, 0x16, 0xd8,
	0xef, 0xc2, 0x4a, 0xea, 0x90, 0x0d, 0x8e, 0xaa, 0x69, 0x47, 0x22, 0x8d, 0xb6, 0x69, 0x24, 0xfc,
	0x28, 0x3f, 0xe6, 0x44, 0xc9, 0xd4, 0x77, 0x97, 0x4c, 0x7d, 0x47, 0xc9, 0xb4, 0x54, 0xc9, 0xd2,
	0xb5, 0x10, 0xcf, 0x0d, 0x66, 0x4e, 0xb2, 0x16, 0xef, 0xab, 0xa0, 0xfa, 0x3f, 0x54, 0xf0, 0x6b,
	0x51, 0xc1, 0x65, 0x68, 0x1b, 0x1c, 0x5d, 0x4b, 0x3b, 0xaa, 0xc4, 0x8d, 0xc0, 0x5b, 0xf4, 0x12,
	0xde, 0xc6, 0x6d, 0x58, 0xe8, 0xfa, 0x34, 0x08, 0x0f, 0xd9, 0x45, 0xa0, 0x9d, 0xfc, 0x26, 0x89,
	0x8b, 0x40, 0x9b, 0x09, 0x9d, 0xf5, 0xd9, 0x02, 0x1d, 0x45, 0x11, 0xcf, 0xaa, 0x08, 0x43, 0x70,
	0xba, 0x61, 0x48, 0xc0, 0xe9, 0x8d, 0x9f, 0xb2, 0x70, 0x3b, 0x71, 0x79, 0x46, 0xbb, 0x10, 0x25,
	0xb6, 0xfd, 0xe9, 0x63, 0xe2, 0xd8, 0x67, 0x52, 0x06, 0xed, 0xc1, 0x8f, 0x92, 0x77, 0x6c, 0x71,
	0x4d, 0x92, 0xb6, 0x37, 0x0b, 0xaa, 0x54, 0xde, 0x2c, 0x34, 0xa5, 0xca, 0x66, 0x41, 0x93, 0x76,
	0xd0, 0xc7, 0x50, 0x4a, 0x08, 0xfc, 0x5b, 0x2c, 0x5d, 0xdd, 0x60, 0x55, 0xa5, 0xdd, 0x0d, 0xd6,
	0xa6, 0xb4, 0xb7, 0xc1, 0xaa, 0x49, 0x18, 0x5d, 0x85, 0x1f, 0x26, 0xac, 0xd1, 0x40, 0x4a, 0xd5,
	0x4d, 0x66, 0x55, 0xaa, 0xdd, 0xa8, 0xc3, 0x52, 0x7c, 0x23, 0x47, 0x45, 0x98, 0x7f, 0x40, 0xa7,
	0xa6, 0x94, 0x41, 0x25, 0xb8, 0xd5, 0x22, 0x81, 0x6d, 0x48, 0x00, 0x95, 0xd9, 0x65, 0xc7, 0xb1,
	0xc9, 0xc8, 0x31, 0xa5, 0x6c, 0xeb, 0xd6, 0xf3, 0x73, 0x39, 0xf3, 0xe2, 0x5c, 0xce, 0xbc, 0x39,
	0x97, 0xc1, 0x0f, 0x0b, 0x19, 0xfc, 0xb2, 0x90, 0xc1, 0xb3, 0x85, 0x0c, 0x9e, 0x2f, 0x64, 0xf0,
	0x62, 0x21, 0x83, 0x3f, 0x17, 0x32, 0xf8, 0x7b, 0x21, 0x67, 0xde, 0x2c, 0x64, 0xf0, 0xf3, 0x6b,
	0x39, 0xf3, 0xfc, 0xb5, 0x9c, 0x79, 0xf1, 0x5a, 0xce, 0x8c, 0x0a, 0xfc, 0xaf, 0x4d, 0xf3, 0x9f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xdc, 0x6c, 0xae, 0xc2, 0x35, 0x0d, 0x00, 0x00,
}

func (x MessageType) String() string {
	s, ok := MessageType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Broadcast) String() string {
	s, ok := Broadcast_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Message) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Message)
	if !ok {
		that2, ok := that.(Message)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	if !this.To.Equal(that1.To) {
		return false
	}
	if this.Broadcast != that1.Broadcast {
		return false
	}
	if !this.Refresh1.Equal(that1.Refresh1) {
		return false
	}
	if !this.Refresh2.Equal(that1.Refresh2) {
		return false
	}
	if !this.Refresh3.Equal(that1.Refresh3) {
		return false
	}
	if !this.Refresh4.Equal(that1.Refresh4) {
		return false
	}
	if !this.Sign1.Equal(that1.Sign1) {
		return false
	}
	if !this.Sign2.Equal(that1.Sign2) {
		return false
	}
	if !this.Sign3.Equal(that1.Sign3) {
		return false
	}
	if !this.Sign4.Equal(that1.Sign4) {
		return false
	}
	if !this.Abort1.Equal(that1.Abort1) {
		return false
	}
	if !this.Abort2.Equal(that1.Abort2) {
		return false
	}
	return true
}
func (this *Refresh1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Refresh1)
	if !ok {
		that2, ok := that.(Refresh1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Hash, that1.Hash) {
		return false
	}
	return true
}
func (this *Refresh2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Refresh2)
	if !ok {
		that2, ok := that.(Refresh2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.HashOfHashes, that1.HashOfHashes) {
		return false
	}
	return true
}
func (this *Refresh3) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Refresh3)
	if !ok {
		that2, ok := that.(Refresh3)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Rho, that1.Rho) {
		return false
	}
	if !this.F.Equal(that1.F) {
		return false
	}
	if len(this.A) != len(that1.A) {
		return false
	}
	for i := range this.A {
		if !this.A[i].Equal(that1.A[i]) {
			return false
		}
	}
	{
		__caster := &IntCaster{}
		if !__caster.Equal(this.N, that1.N) {
			return false
		}
	}
	{
		__caster := &IntCaster{}
		if !__caster.Equal(this.S, that1.S) {
			return false
		}
	}
	{
		__caster := &IntCaster{}
		if !__caster.Equal(this.T, that1.T) {
			return false
		}
	}
	if !bytes.Equal(this.U, that1.U) {
		return false
	}
	return true
}
func (this *Refresh4) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Refresh4)
	if !ok {
		that2, ok := that.(Refresh4)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Mod.Equal(that1.Mod) {
		return false
	}
	if !this.Prm.Equal(that1.Prm) {
		return false
	}
	{
		__caster := &CiphertextCaster{}
		if !__caster.Equal(this.C, that1.C) {
			return false
		}
	}
	if len(this.SchF) != len(that1.SchF) {
		return false
	}
	for i := range this.SchF {
		if !this.SchF[i].Equal(that1.SchF[i]) {
			return false
		}
	}
	return true
}
func (this *Sign1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sign1)
	if !ok {
		that2, ok := that.(Sign1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Enc.Equal(that1.Enc) {
		return false
	}
	{
		__caster := &CiphertextCaster{}
		if !__caster.Equal(this.K, that1.K) {
			return false
		}
	}
	{
		__caster := &CiphertextCaster{}
		if !__caster.Equal(this.G, that1.G) {
			return false
		}
	}
	return true
}
func (this *Sign2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sign2)
	if !ok {
		that2, ok := that.(Sign2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.HashKG, that1.HashKG) {
		return false
	}
	if !this.Gamma.Equal(that1.Gamma) {
		return false
	}
	{
		__caster := &CiphertextCaster{}
		if !__caster.Equal(this.D, that1.D) {
			return false
		}
	}
	{
		__caster := &CiphertextCaster{}
		if !__caster.Equal(this.F, that1.F) {
			return false
		}
	}
	{
		__caster := &CiphertextCaster{}
		if !__caster.Equal(this.DHat, that1.DHat) {
			return false
		}
	}
	{
		__caster := &CiphertextCaster{}
		if !__caster.Equal(this.FHat, that1.FHat) {
			return false
		}
	}
	if !this.ProofAffG.Equal(that1.ProofAffG) {
		return false
	}
	if !this.ProofAffGHat.Equal(that1.ProofAffGHat) {
		return false
	}
	if !this.ProofLog.Equal(that1.ProofLog) {
		return false
	}
	return true
}
func (this *Sign3) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sign3)
	if !ok {
		that2, ok := that.(Sign3)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Delta.Equal(that1.Delta) {
		return false
	}
	if !this.DeltaGroup.Equal(that1.DeltaGroup) {
		return false
	}
	if !this.ProofLog.Equal(that1.ProofLog) {
		return false
	}
	return true
}
func (this *Sign4) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sign4)
	if !ok {
		that2, ok := that.(Sign4)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sigma.Equal(that1.Sigma) {
		return false
	}
	return true
}
func (this *Abort1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Abort1)
	if !ok {
		that2, ok := that.(Abort1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProofAffg) != len(that1.ProofAffg) {
		return false
	}
	for i := range this.ProofAffg {
		if !this.ProofAffg[i].Equal(that1.ProofAffg[i]) {
			return false
		}
	}
	if !this.ProofMul.Equal(that1.ProofMul) {
		return false
	}
	if len(this.ProofDec) != len(that1.ProofDec) {
		return false
	}
	for i := range this.ProofDec {
		if !this.ProofDec[i].Equal(that1.ProofDec[i]) {
			return false
		}
	}
	return true
}
func (this *Abort2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Abort2)
	if !ok {
		that2, ok := that.(Abort2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProofAffg) != len(that1.ProofAffg) {
		return false
	}
	for i := range this.ProofAffg {
		if !this.ProofAffg[i].Equal(that1.ProofAffg[i]) {
			return false
		}
	}
	if len(this.ProofMul) != len(that1.ProofMul) {
		return false
	}
	for i := range this.ProofMul {
		if !this.ProofMul[i].Equal(that1.ProofMul[i]) {
			return false
		}
	}
	if len(this.ProofDec) != len(that1.ProofDec) {
		return false
	}
	for i := range this.ProofDec {
		if !this.ProofDec[i].Equal(that1.ProofDec[i]) {
			return false
		}
	}
	return true
}
func (this *Frost1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Frost1)
	if !ok {
		that2, ok := that.(Frost1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.D.Equal(that1.D) {
		return false
	}
	if !this.E.Equal(that1.E) {
		return false
	}
	return true
}
func (this *Frost2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Frost2)
	if !ok {
		that2, ok := that.(Frost2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Z.Equal(that1.Z) {
		return false
	}
	return true
}
func (this *Message) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&pb.Message{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	s = append(s, "To: "+fmt.Sprintf("%#v", this.To)+",\n")
	s = append(s, "Broadcast: "+fmt.Sprintf("%#v", this.Broadcast)+",\n")
	if this.Refresh1 != nil {
		s = append(s, "Refresh1: "+fmt.Sprintf("%#v", this.Refresh1)+",\n")
	}
	if this.Refresh2 != nil {
		s = append(s, "Refresh2: "+fmt.Sprintf("%#v", this.Refresh2)+",\n")
	}
	if this.Refresh3 != nil {
		s = append(s, "Refresh3: "+fmt.Sprintf("%#v", this.Refresh3)+",\n")
	}
	if this.Refresh4 != nil {
		s = append(s, "Refresh4: "+fmt.Sprintf("%#v", this.Refresh4)+",\n")
	}
	if this.Sign1 != nil {
		s = append(s, "Sign1: "+fmt.Sprintf("%#v", this.Sign1)+",\n")
	}
	if this.Sign2 != nil {
		s = append(s, "Sign2: "+fmt.Sprintf("%#v", this.Sign2)+",\n")
	}
	if this.Sign3 != nil {
		s = append(s, "Sign3: "+fmt.Sprintf("%#v", this.Sign3)+",\n")
	}
	if this.Sign4 != nil {
		s = append(s, "Sign4: "+fmt.Sprintf("%#v", this.Sign4)+",\n")
	}
	if this.Abort1 != nil {
		s = append(s, "Abort1: "+fmt.Sprintf("%#v", this.Abort1)+",\n")
	}
	if this.Abort2 != nil {
		s = append(s, "Abort2: "+fmt.Sprintf("%#v", this.Abort2)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Refresh1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.Refresh1{")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Refresh2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.Refresh2{")
	s = append(s, "HashOfHashes: "+fmt.Sprintf("%#v", this.HashOfHashes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Refresh3) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&pb.Refresh3{")
	s = append(s, "Rho: "+fmt.Sprintf("%#v", this.Rho)+",\n")
	if this.F != nil {
		s = append(s, "F: "+fmt.Sprintf("%#v", this.F)+",\n")
	}
	if this.A != nil {
		s = append(s, "A: "+fmt.Sprintf("%#v", this.A)+",\n")
	}
	s = append(s, "N: "+fmt.Sprintf("%#v", this.N)+",\n")
	s = append(s, "S: "+fmt.Sprintf("%#v", this.S)+",\n")
	s = append(s, "T: "+fmt.Sprintf("%#v", this.T)+",\n")
	s = append(s, "U: "+fmt.Sprintf("%#v", this.U)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Refresh4) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&pb.Refresh4{")
	if this.Mod != nil {
		s = append(s, "Mod: "+fmt.Sprintf("%#v", this.Mod)+",\n")
	}
	if this.Prm != nil {
		s = append(s, "Prm: "+fmt.Sprintf("%#v", this.Prm)+",\n")
	}
	s = append(s, "C: "+fmt.Sprintf("%#v", this.C)+",\n")
	if this.SchF != nil {
		s = append(s, "SchF: "+fmt.Sprintf("%#v", this.SchF)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sign1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.Sign1{")
	if this.Enc != nil {
		s = append(s, "Enc: "+fmt.Sprintf("%#v", this.Enc)+",\n")
	}
	s = append(s, "K: "+fmt.Sprintf("%#v", this.K)+",\n")
	s = append(s, "G: "+fmt.Sprintf("%#v", this.G)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sign2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&pb.Sign2{")
	s = append(s, "HashKG: "+fmt.Sprintf("%#v", this.HashKG)+",\n")
	if this.Gamma != nil {
		s = append(s, "Gamma: "+fmt.Sprintf("%#v", this.Gamma)+",\n")
	}
	s = append(s, "D: "+fmt.Sprintf("%#v", this.D)+",\n")
	s = append(s, "F: "+fmt.Sprintf("%#v", this.F)+",\n")
	s = append(s, "DHat: "+fmt.Sprintf("%#v", this.DHat)+",\n")
	s = append(s, "FHat: "+fmt.Sprintf("%#v", this.FHat)+",\n")
	if this.ProofAffG != nil {
		s = append(s, "ProofAffG: "+fmt.Sprintf("%#v", this.ProofAffG)+",\n")
	}
	if this.ProofAffGHat != nil {
		s = append(s, "ProofAffGHat: "+fmt.Sprintf("%#v", this.ProofAffGHat)+",\n")
	}
	if this.ProofLog != nil {
		s = append(s, "ProofLog: "+fmt.Sprintf("%#v", this.ProofLog)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sign3) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.Sign3{")
	if this.Delta != nil {
		s = append(s, "Delta: "+fmt.Sprintf("%#v", this.Delta)+",\n")
	}
	if this.DeltaGroup != nil {
		s = append(s, "DeltaGroup: "+fmt.Sprintf("%#v", this.DeltaGroup)+",\n")
	}
	if this.ProofLog != nil {
		s = append(s, "ProofLog: "+fmt.Sprintf("%#v", this.ProofLog)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sign4) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.Sign4{")
	if this.Sigma != nil {
		s = append(s, "Sigma: "+fmt.Sprintf("%#v", this.Sigma)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Abort1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.Abort1{")
	keysForProofAffg := make([]string, 0, len(this.ProofAffg))
	for k, _ := range this.ProofAffg {
		keysForProofAffg = append(keysForProofAffg, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProofAffg)
	mapStringForProofAffg := "map[string]*ZKAffG{"
	for _, k := range keysForProofAffg {
		mapStringForProofAffg += fmt.Sprintf("%#v: %#v,", k, this.ProofAffg[k])
	}
	mapStringForProofAffg += "}"
	if this.ProofAffg != nil {
		s = append(s, "ProofAffg: "+mapStringForProofAffg+",\n")
	}
	if this.ProofMul != nil {
		s = append(s, "ProofMul: "+fmt.Sprintf("%#v", this.ProofMul)+",\n")
	}
	keysForProofDec := make([]string, 0, len(this.ProofDec))
	for k, _ := range this.ProofDec {
		keysForProofDec = append(keysForProofDec, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProofDec)
	mapStringForProofDec := "map[string]*ZKDec{"
	for _, k := range keysForProofDec {
		mapStringForProofDec += fmt.Sprintf("%#v: %#v,", k, this.ProofDec[k])
	}
	mapStringForProofDec += "}"
	if this.ProofDec != nil {
		s = append(s, "ProofDec: "+mapStringForProofDec+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Abort2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.Abort2{")
	keysForProofAffg := make([]string, 0, len(this.ProofAffg))
	for k, _ := range this.ProofAffg {
		keysForProofAffg = append(keysForProofAffg, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProofAffg)
	mapStringForProofAffg := "map[string]*ZKAffG{"
	for _, k := range keysForProofAffg {
		mapStringForProofAffg += fmt.Sprintf("%#v: %#v,", k, this.ProofAffg[k])
	}
	mapStringForProofAffg += "}"
	if this.ProofAffg != nil {
		s = append(s, "ProofAffg: "+mapStringForProofAffg+",\n")
	}
	keysForProofMul := make([]string, 0, len(this.ProofMul))
	for k, _ := range this.ProofMul {
		keysForProofMul = append(keysForProofMul, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProofMul)
	mapStringForProofMul := "map[string]*ZKMulStar{"
	for _, k := range keysForProofMul {
		mapStringForProofMul += fmt.Sprintf("%#v: %#v,", k, this.ProofMul[k])
	}
	mapStringForProofMul += "}"
	if this.ProofMul != nil {
		s = append(s, "ProofMul: "+mapStringForProofMul+",\n")
	}
	keysForProofDec := make([]string, 0, len(this.ProofDec))
	for k, _ := range this.ProofDec {
		keysForProofDec = append(keysForProofDec, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProofDec)
	mapStringForProofDec := "map[string]*ZKDec{"
	for _, k := range keysForProofDec {
		mapStringForProofDec += fmt.Sprintf("%#v: %#v,", k, this.ProofDec[k])
	}
	mapStringForProofDec += "}"
	if this.ProofDec != nil {
		s = append(s, "ProofDec: "+mapStringForProofDec+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Frost1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.Frost1{")
	if this.D != nil {
		s = append(s, "D: "+fmt.Sprintf("%#v", this.D)+",\n")
	}
	if this.E != nil {
		s = append(s, "E: "+fmt.Sprintf("%#v", this.E)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Frost2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.Frost2{")
	if this.Z != nil {
		s = append(s, "Z: "+fmt.Sprintf("%#v", this.Z)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMessage(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Abort2 != nil {
		{
			size, err := m.Abort2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.Abort1 != nil {
		{
			size, err := m.Abort1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.Sign4 != nil {
		{
			size, err := m.Sign4.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Sign3 != nil {
		{
			size, err := m.Sign3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.Sign2 != nil {
		{
			size, err := m.Sign2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Sign1 != nil {
		{
			size, err := m.Sign1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Refresh4 != nil {
		{
			size, err := m.Refresh4.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Refresh3 != nil {
		{
			size, err := m.Refresh3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Refresh2 != nil {
		{
			size, err := m.Refresh2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Refresh1 != nil {
		{
			size, err := m.Refresh1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Broadcast != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Broadcast))
		i--
		dAtA[i] = 0x20
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Refresh1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Refresh1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Refresh1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Refresh2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Refresh2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Refresh2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HashOfHashes) > 0 {
		i -= len(m.HashOfHashes)
		copy(dAtA[i:], m.HashOfHashes)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.HashOfHashes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Refresh3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Refresh3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Refresh3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.U) > 0 {
		i -= len(m.U)
		copy(dAtA[i:], m.U)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.U)))
		i--
		dAtA[i] = 0x3a
	}
	{
		__caster := &IntCaster{}
		size := __caster.Size(m.T)
		i -= size
		if _, err := __caster.MarshalTo(m.T, dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		__caster := &IntCaster{}
		size := __caster.Size(m.S)
		i -= size
		if _, err := __caster.MarshalTo(m.S, dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		__caster := &IntCaster{}
		size := __caster.Size(m.N)
		i -= size
		if _, err := __caster.MarshalTo(m.N, dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.A) > 0 {
		for iNdEx := len(m.A) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.A[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.F != nil {
		{
			size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Rho) > 0 {
		i -= len(m.Rho)
		copy(dAtA[i:], m.Rho)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Rho)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Refresh4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Refresh4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Refresh4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SchF) > 0 {
		for iNdEx := len(m.SchF) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SchF[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		__caster := &CiphertextCaster{}
		size := __caster.Size(m.C)
		i -= size
		if _, err := __caster.MarshalTo(m.C, dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Prm != nil {
		{
			size, err := m.Prm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Mod != nil {
		{
			size, err := m.Mod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Sign1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sign1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sign1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		__caster := &CiphertextCaster{}
		size := __caster.Size(m.G)
		i -= size
		if _, err := __caster.MarshalTo(m.G, dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		__caster := &CiphertextCaster{}
		size := __caster.Size(m.K)
		i -= size
		if _, err := __caster.MarshalTo(m.K, dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Enc != nil {
		{
			size, err := m.Enc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Sign2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sign2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sign2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProofLog != nil {
		{
			size, err := m.ProofLog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ProofAffGHat != nil {
		{
			size, err := m.ProofAffGHat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ProofAffG != nil {
		{
			size, err := m.ProofAffG.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	{
		__caster := &CiphertextCaster{}
		size := __caster.Size(m.FHat)
		i -= size
		if _, err := __caster.MarshalTo(m.FHat, dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		__caster := &CiphertextCaster{}
		size := __caster.Size(m.DHat)
		i -= size
		if _, err := __caster.MarshalTo(m.DHat, dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		__caster := &CiphertextCaster{}
		size := __caster.Size(m.F)
		i -= size
		if _, err := __caster.MarshalTo(m.F, dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		__caster := &CiphertextCaster{}
		size := __caster.Size(m.D)
		i -= size
		if _, err := __caster.MarshalTo(m.D, dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Gamma != nil {
		{
			size, err := m.Gamma.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.HashKG) > 0 {
		i -= len(m.HashKG)
		copy(dAtA[i:], m.HashKG)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.HashKG)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Sign3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sign3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sign3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProofLog != nil {
		{
			size, err := m.ProofLog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DeltaGroup != nil {
		{
			size, err := m.DeltaGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Delta != nil {
		{
			size, err := m.Delta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Sign4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sign4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sign4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sigma != nil {
		{
			size, err := m.Sigma.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Abort1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Abort1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Abort1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofDec) > 0 {
		keysForProofDec := make([]string, 0, len(m.ProofDec))
		for k := range m.ProofDec {
			keysForProofDec = append(keysForProofDec, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForProofDec)
		for iNdEx := len(keysForProofDec) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ProofDec[string(keysForProofDec[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMessage(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForProofDec[iNdEx])
			copy(dAtA[i:], keysForProofDec[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(keysForProofDec[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ProofMul != nil {
		{
			size, err := m.ProofMul.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProofAffg) > 0 {
		keysForProofAffg := make([]string, 0, len(m.ProofAffg))
		for k := range m.ProofAffg {
			keysForProofAffg = append(keysForProofAffg, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForProofAffg)
		for iNdEx := len(keysForProofAffg) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ProofAffg[string(keysForProofAffg[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMessage(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForProofAffg[iNdEx])
			copy(dAtA[i:], keysForProofAffg[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(keysForProofAffg[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Abort2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Abort2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Abort2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofDec) > 0 {
		keysForProofDec := make([]string, 0, len(m.ProofDec))
		for k := range m.ProofDec {
			keysForProofDec = append(keysForProofDec, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForProofDec)
		for iNdEx := len(keysForProofDec) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ProofDec[string(keysForProofDec[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMessage(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForProofDec[iNdEx])
			copy(dAtA[i:], keysForProofDec[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(keysForProofDec[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ProofMul) > 0 {
		keysForProofMul := make([]string, 0, len(m.ProofMul))
		for k := range m.ProofMul {
			keysForProofMul = append(keysForProofMul, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForProofMul)
		for iNdEx := len(keysForProofMul) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ProofMul[string(keysForProofMul[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMessage(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForProofMul[iNdEx])
			copy(dAtA[i:], keysForProofMul[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(keysForProofMul[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ProofAffg) > 0 {
		keysForProofAffg := make([]string, 0, len(m.ProofAffg))
		for k := range m.ProofAffg {
			keysForProofAffg = append(keysForProofAffg, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForProofAffg)
		for iNdEx := len(keysForProofAffg) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ProofAffg[string(keysForProofAffg[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMessage(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForProofAffg[iNdEx])
			copy(dAtA[i:], keysForProofAffg[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(keysForProofAffg[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Frost1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Frost1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Frost1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.E != nil {
		{
			size, err := m.E.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.D != nil {
		{
			size, err := m.D.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Frost2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Frost2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Frost2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Z != nil {
		{
			size, err := m.Z.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Broadcast != 0 {
		n += 1 + sovMessage(uint64(m.Broadcast))
	}
	if m.Refresh1 != nil {
		l = m.Refresh1.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Refresh2 != nil {
		l = m.Refresh2.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Refresh3 != nil {
		l = m.Refresh3.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Refresh4 != nil {
		l = m.Refresh4.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Sign1 != nil {
		l = m.Sign1.Size()
		n += 2 + l + sovMessage(uint64(l))
	}
	if m.Sign2 != nil {
		l = m.Sign2.Size()
		n += 2 + l + sovMessage(uint64(l))
	}
	if m.Sign3 != nil {
		l = m.Sign3.Size()
		n += 2 + l + sovMessage(uint64(l))
	}
	if m.Sign4 != nil {
		l = m.Sign4.Size()
		n += 2 + l + sovMessage(uint64(l))
	}
	if m.Abort1 != nil {
		l = m.Abort1.Size()
		n += 2 + l + sovMessage(uint64(l))
	}
	if m.Abort2 != nil {
		l = m.Abort2.Size()
		n += 2 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Refresh1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Refresh2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HashOfHashes)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Refresh3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Rho)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.F != nil {
		l = m.F.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.A) > 0 {
		for _, e := range m.A {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	{
		__caster := &IntCaster{}
		l = __caster.Size(m.N)
		n += 1 + l + sovMessage(uint64(l))
	}
	{
		__caster := &IntCaster{}
		l = __caster.Size(m.S)
		n += 1 + l + sovMessage(uint64(l))
	}
	{
		__caster := &IntCaster{}
		l = __caster.Size(m.T)
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.U)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Refresh4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mod != nil {
		l = m.Mod.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Prm != nil {
		l = m.Prm.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	{
		__caster := &CiphertextCaster{}
		l = __caster.Size(m.C)
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.SchF) > 0 {
		for _, e := range m.SchF {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *Sign1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enc != nil {
		l = m.Enc.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	{
		__caster := &CiphertextCaster{}
		l = __caster.Size(m.K)
		n += 1 + l + sovMessage(uint64(l))
	}
	{
		__caster := &CiphertextCaster{}
		l = __caster.Size(m.G)
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Sign2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HashKG)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Gamma != nil {
		l = m.Gamma.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	{
		__caster := &CiphertextCaster{}
		l = __caster.Size(m.D)
		n += 1 + l + sovMessage(uint64(l))
	}
	{
		__caster := &CiphertextCaster{}
		l = __caster.Size(m.F)
		n += 1 + l + sovMessage(uint64(l))
	}
	{
		__caster := &CiphertextCaster{}
		l = __caster.Size(m.DHat)
		n += 1 + l + sovMessage(uint64(l))
	}
	{
		__caster := &CiphertextCaster{}
		l = __caster.Size(m.FHat)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ProofAffG != nil {
		l = m.ProofAffG.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ProofAffGHat != nil {
		l = m.ProofAffGHat.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ProofLog != nil {
		l = m.ProofLog.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Sign3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delta != nil {
		l = m.Delta.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.DeltaGroup != nil {
		l = m.DeltaGroup.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ProofLog != nil {
		l = m.ProofLog.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Sign4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sigma != nil {
		l = m.Sigma.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Abort1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProofAffg) > 0 {
		for k, v := range m.ProofAffg {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessage(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if m.ProofMul != nil {
		l = m.ProofMul.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.ProofDec) > 0 {
		for k, v := range m.ProofDec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessage(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Abort2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProofAffg) > 0 {
		for k, v := range m.ProofAffg {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessage(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if len(m.ProofMul) > 0 {
		for k, v := range m.ProofMul {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessage(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	if len(m.ProofDec) > 0 {
		for k, v := range m.ProofDec {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessage(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMessage(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Frost1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.D != nil {
		l = m.D.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.E != nil {
		l = m.E.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Frost2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Z != nil {
		l = m.Z.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Message) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Message{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`To:` + fmt.Sprintf("%v", this.To) + `,`,
		`Broadcast:` + fmt.Sprintf("%v", this.Broadcast) + `,`,
		`Refresh1:` + strings.Replace(this.Refresh1.String(), "Refresh1", "Refresh1", 1) + `,`,
		`Refresh2:` + strings.Replace(this.Refresh2.String(), "Refresh2", "Refresh2", 1) + `,`,
		`Refresh3:` + strings.Replace(this.Refresh3.String(), "Refresh3", "Refresh3", 1) + `,`,
		`Refresh4:` + strings.Replace(this.Refresh4.String(), "Refresh4", "Refresh4", 1) + `,`,
		`Sign1:` + strings.Replace(this.Sign1.String(), "Sign1", "Sign1", 1) + `,`,
		`Sign2:` + strings.Replace(this.Sign2.String(), "Sign2", "Sign2", 1) + `,`,
		`Sign3:` + strings.Replace(this.Sign3.String(), "Sign3", "Sign3", 1) + `,`,
		`Sign4:` + strings.Replace(this.Sign4.String(), "Sign4", "Sign4", 1) + `,`,
		`Abort1:` + strings.Replace(this.Abort1.String(), "Abort1", "Abort1", 1) + `,`,
		`Abort2:` + strings.Replace(this.Abort2.String(), "Abort2", "Abort2", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Refresh1) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Refresh1{`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Refresh2) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Refresh2{`,
		`HashOfHashes:` + fmt.Sprintf("%v", this.HashOfHashes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Refresh3) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForA := "[]*Point{"
	for _, f := range this.A {
		repeatedStringForA += strings.Replace(fmt.Sprintf("%v", f), "Point", "Point", 1) + ","
	}
	repeatedStringForA += "}"
	s := strings.Join([]string{`&Refresh3{`,
		`Rho:` + fmt.Sprintf("%v", this.Rho) + `,`,
		`F:` + strings.Replace(fmt.Sprintf("%v", this.F), "PolynomialExponent", "PolynomialExponent", 1) + `,`,
		`A:` + repeatedStringForA + `,`,
		`N:` + fmt.Sprintf("%v", this.N) + `,`,
		`S:` + fmt.Sprintf("%v", this.S) + `,`,
		`T:` + fmt.Sprintf("%v", this.T) + `,`,
		`U:` + fmt.Sprintf("%v", this.U) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Refresh4) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSchF := "[]*Scalar{"
	for _, f := range this.SchF {
		repeatedStringForSchF += strings.Replace(fmt.Sprintf("%v", f), "Scalar", "Scalar", 1) + ","
	}
	repeatedStringForSchF += "}"
	s := strings.Join([]string{`&Refresh4{`,
		`Mod:` + strings.Replace(fmt.Sprintf("%v", this.Mod), "ZKMod", "ZKMod", 1) + `,`,
		`Prm:` + strings.Replace(fmt.Sprintf("%v", this.Prm), "ZKPrm", "ZKPrm", 1) + `,`,
		`C:` + fmt.Sprintf("%v", this.C) + `,`,
		`SchF:` + repeatedStringForSchF + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sign1) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sign1{`,
		`Enc:` + strings.Replace(fmt.Sprintf("%v", this.Enc), "ZKEnc", "ZKEnc", 1) + `,`,
		`K:` + fmt.Sprintf("%v", this.K) + `,`,
		`G:` + fmt.Sprintf("%v", this.G) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sign2) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sign2{`,
		`HashKG:` + fmt.Sprintf("%v", this.HashKG) + `,`,
		`Gamma:` + strings.Replace(fmt.Sprintf("%v", this.Gamma), "Point", "Point", 1) + `,`,
		`D:` + fmt.Sprintf("%v", this.D) + `,`,
		`F:` + fmt.Sprintf("%v", this.F) + `,`,
		`DHat:` + fmt.Sprintf("%v", this.DHat) + `,`,
		`FHat:` + fmt.Sprintf("%v", this.FHat) + `,`,
		`ProofAffG:` + strings.Replace(fmt.Sprintf("%v", this.ProofAffG), "ZKAffG", "ZKAffG", 1) + `,`,
		`ProofAffGHat:` + strings.Replace(fmt.Sprintf("%v", this.ProofAffGHat), "ZKAffG", "ZKAffG", 1) + `,`,
		`ProofLog:` + strings.Replace(fmt.Sprintf("%v", this.ProofLog), "ZKLogStar", "ZKLogStar", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sign3) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sign3{`,
		`Delta:` + strings.Replace(fmt.Sprintf("%v", this.Delta), "Scalar", "Scalar", 1) + `,`,
		`DeltaGroup:` + strings.Replace(fmt.Sprintf("%v", this.DeltaGroup), "Point", "Point", 1) + `,`,
		`ProofLog:` + strings.Replace(fmt.Sprintf("%v", this.ProofLog), "ZKLogStar", "ZKLogStar", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sign4) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sign4{`,
		`Sigma:` + strings.Replace(fmt.Sprintf("%v", this.Sigma), "Scalar", "Scalar", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Abort1) String() string {
	if this == nil {
		return "nil"
	}
	keysForProofAffg := make([]string, 0, len(this.ProofAffg))
	for k, _ := range this.ProofAffg {
		keysForProofAffg = append(keysForProofAffg, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProofAffg)
	mapStringForProofAffg := "map[string]*ZKAffG{"
	for _, k := range keysForProofAffg {
		mapStringForProofAffg += fmt.Sprintf("%v: %v,", k, this.ProofAffg[k])
	}
	mapStringForProofAffg += "}"
	keysForProofDec := make([]string, 0, len(this.ProofDec))
	for k, _ := range this.ProofDec {
		keysForProofDec = append(keysForProofDec, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProofDec)
	mapStringForProofDec := "map[string]*ZKDec{"
	for _, k := range keysForProofDec {
		mapStringForProofDec += fmt.Sprintf("%v: %v,", k, this.ProofDec[k])
	}
	mapStringForProofDec += "}"
	s := strings.Join([]string{`&Abort1{`,
		`ProofAffg:` + mapStringForProofAffg + `,`,
		`ProofMul:` + strings.Replace(fmt.Sprintf("%v", this.ProofMul), "ZKMul", "ZKMul", 1) + `,`,
		`ProofDec:` + mapStringForProofDec + `,`,
		`}`,
	}, "")
	return s
}
func (this *Abort2) String() string {
	if this == nil {
		return "nil"
	}
	keysForProofAffg := make([]string, 0, len(this.ProofAffg))
	for k, _ := range this.ProofAffg {
		keysForProofAffg = append(keysForProofAffg, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProofAffg)
	mapStringForProofAffg := "map[string]*ZKAffG{"
	for _, k := range keysForProofAffg {
		mapStringForProofAffg += fmt.Sprintf("%v: %v,", k, this.ProofAffg[k])
	}
	mapStringForProofAffg += "}"
	keysForProofMul := make([]string, 0, len(this.ProofMul))
	for k, _ := range this.ProofMul {
		keysForProofMul = append(keysForProofMul, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProofMul)
	mapStringForProofMul := "map[string]*ZKMulStar{"
	for _, k := range keysForProofMul {
		mapStringForProofMul += fmt.Sprintf("%v: %v,", k, this.ProofMul[k])
	}
	mapStringForProofMul += "}"
	keysForProofDec := make([]string, 0, len(this.ProofDec))
	for k, _ := range this.ProofDec {
		keysForProofDec = append(keysForProofDec, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProofDec)
	mapStringForProofDec := "map[string]*ZKDec{"
	for _, k := range keysForProofDec {
		mapStringForProofDec += fmt.Sprintf("%v: %v,", k, this.ProofDec[k])
	}
	mapStringForProofDec += "}"
	s := strings.Join([]string{`&Abort2{`,
		`ProofAffg:` + mapStringForProofAffg + `,`,
		`ProofMul:` + mapStringForProofMul + `,`,
		`ProofDec:` + mapStringForProofDec + `,`,
		`}`,
	}, "")
	return s
}
func (this *Frost1) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Frost1{`,
		`D:` + strings.Replace(fmt.Sprintf("%v", this.D), "Point", "Point", 1) + `,`,
		`E:` + strings.Replace(fmt.Sprintf("%v", this.E), "Point", "Point", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Frost2) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Frost2{`,
		`Z:` + strings.Replace(fmt.Sprintf("%v", this.Z), "Scalar", "Scalar", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMessage(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = github_com_taurusgroup_cmp_ecdsa_pkg_party.ID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = github_com_taurusgroup_cmp_ecdsa_pkg_party.ID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Broadcast", wireType)
			}
			m.Broadcast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Broadcast |= Broadcast(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refresh1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Refresh1 == nil {
				m.Refresh1 = &Refresh1{}
			}
			if err := m.Refresh1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refresh2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Refresh2 == nil {
				m.Refresh2 = &Refresh2{}
			}
			if err := m.Refresh2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refresh3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Refresh3 == nil {
				m.Refresh3 = &Refresh3{}
			}
			if err := m.Refresh3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refresh4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Refresh4 == nil {
				m.Refresh4 = &Refresh4{}
			}
			if err := m.Refresh4.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign1 == nil {
				m.Sign1 = &Sign1{}
			}
			if err := m.Sign1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign2 == nil {
				m.Sign2 = &Sign2{}
			}
			if err := m.Sign2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign3 == nil {
				m.Sign3 = &Sign3{}
			}
			if err := m.Sign3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign4 == nil {
				m.Sign4 = &Sign4{}
			}
			if err := m.Sign4.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abort1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Abort1 == nil {
				m.Abort1 = &Abort1{}
			}
			if err := m.Abort1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abort2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Abort2 == nil {
				m.Abort2 = &Abort2{}
			}
			if err := m.Abort2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Refresh1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Refresh1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Refresh1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Refresh2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Refresh2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Refresh2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOfHashes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashOfHashes = append(m.HashOfHashes[:0], dAtA[iNdEx:postIndex]...)
			if m.HashOfHashes == nil {
				m.HashOfHashes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Refresh3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Refresh3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Refresh3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rho", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rho = append(m.Rho[:0], dAtA[iNdEx:postIndex]...)
			if m.Rho == nil {
				m.Rho = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.F == nil {
				m.F = &PolynomialExponent{}
			}
			if err := m.F.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A = append(m.A, &Point{})
			if err := m.A[len(m.A)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			{
				__caster := &IntCaster{}
				if tmp, err := __caster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				} else {
					m.N = tmp
				}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			{
				__caster := &IntCaster{}
				if tmp, err := __caster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				} else {
					m.S = tmp
				}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			{
				__caster := &IntCaster{}
				if tmp, err := __caster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				} else {
					m.T = tmp
				}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field U", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.U = append(m.U[:0], dAtA[iNdEx:postIndex]...)
			if m.U == nil {
				m.U = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Refresh4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Refresh4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Refresh4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mod == nil {
				m.Mod = &ZKMod{}
			}
			if err := m.Mod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prm == nil {
				m.Prm = &ZKPrm{}
			}
			if err := m.Prm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			{
				__caster := &CiphertextCaster{}
				if tmp, err := __caster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				} else {
					m.C = tmp
				}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchF", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchF = append(m.SchF, &Scalar{})
			if err := m.SchF[len(m.SchF)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sign1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sign1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sign1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enc == nil {
				m.Enc = &ZKEnc{}
			}
			if err := m.Enc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			{
				__caster := &CiphertextCaster{}
				if tmp, err := __caster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				} else {
					m.K = tmp
				}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			{
				__caster := &CiphertextCaster{}
				if tmp, err := __caster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				} else {
					m.G = tmp
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sign2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sign2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sign2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashKG", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashKG = append(m.HashKG[:0], dAtA[iNdEx:postIndex]...)
			if m.HashKG == nil {
				m.HashKG = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gamma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gamma == nil {
				m.Gamma = &Point{}
			}
			if err := m.Gamma.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			{
				__caster := &CiphertextCaster{}
				if tmp, err := __caster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				} else {
					m.D = tmp
				}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			{
				__caster := &CiphertextCaster{}
				if tmp, err := __caster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				} else {
					m.F = tmp
				}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHat", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			{
				__caster := &CiphertextCaster{}
				if tmp, err := __caster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				} else {
					m.DHat = tmp
				}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FHat", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			{
				__caster := &CiphertextCaster{}
				if tmp, err := __caster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
					return err
				} else {
					m.FHat = tmp
				}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofAffG", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofAffG == nil {
				m.ProofAffG = &ZKAffG{}
			}
			if err := m.ProofAffG.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofAffGHat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofAffGHat == nil {
				m.ProofAffGHat = &ZKAffG{}
			}
			if err := m.ProofAffGHat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofLog == nil {
				m.ProofLog = &ZKLogStar{}
			}
			if err := m.ProofLog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sign3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sign3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sign3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta == nil {
				m.Delta = &Scalar{}
			}
			if err := m.Delta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeltaGroup == nil {
				m.DeltaGroup = &Point{}
			}
			if err := m.DeltaGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofLog == nil {
				m.ProofLog = &ZKLogStar{}
			}
			if err := m.ProofLog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sign4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sign4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sign4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sigma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sigma == nil {
				m.Sigma = &Scalar{}
			}
			if err := m.Sigma.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Abort1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Abort1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Abort1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofAffg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofAffg == nil {
				m.ProofAffg = make(map[string]*ZKAffG)
			}
			var mapkey string
			var mapvalue *ZKAffG
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessage
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMessage
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ZKAffG{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProofAffg[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofMul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofMul == nil {
				m.ProofMul = &ZKMul{}
			}
			if err := m.ProofMul.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofDec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofDec == nil {
				m.ProofDec = make(map[string]*ZKDec)
			}
			var mapkey string
			var mapvalue *ZKDec
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessage
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMessage
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ZKDec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProofDec[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Abort2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Abort2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Abort2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofAffg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofAffg == nil {
				m.ProofAffg = make(map[string]*ZKAffG)
			}
			var mapkey string
			var mapvalue *ZKAffG
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessage
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMessage
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ZKAffG{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProofAffg[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofMul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofMul == nil {
				m.ProofMul = make(map[string]*ZKMulStar)
			}
			var mapkey string
			var mapvalue *ZKMulStar
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessage
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMessage
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ZKMulStar{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProofMul[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofDec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofDec == nil {
				m.ProofDec = make(map[string]*ZKDec)
			}
			var mapkey string
			var mapvalue *ZKDec
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessage
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMessage
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ZKDec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProofDec[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Frost1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Frost1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Frost1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.D == nil {
				m.D = &Point{}
			}
			if err := m.D.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.E == nil {
				m.E = &Point{}
			}
			if err := m.E.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Frost2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Frost2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Frost2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Z == nil {
				m.Z = &Scalar{}
			}
			if err := m.Z.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
